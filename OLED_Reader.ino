#include "GyverOLED.h"                            // Подключение библиотек
#include "GyverButton.h"

GyverOLED<SSD1306_128x32, OLED_NO_BUFFER> oled;   // Объявлеем дисплей
GButton button(3); // Объявляем кнопку

//                                                <-- ТЕКСТ -->
const char text[] PROGMEM = {"<-- Функции ОДС --> Опорно-двигательная система человека состоит из двух частей: пассивной (скелет со связочно-суставным аппаратом) и активной (мышцы). Скелет, состоящий из костей, выполняет защитную и опорную функции. Мышцы, рефлекторно сокращаясь, приводят в движение кости. Функиции ОДС: 1.опорная—поддержание всех других систем и органов, сохранение формы тела; 2. двигательная—передвижение в пространстве тела и его частей; 3. защитная—ограничивая внутренние полости, предохраняет от внешних воздействий расположенные в них внутренние органы. Основными структурными единицами опорно-двигательной системы являются кости и мышцы. <-- Строение и состав кости --> Основной структурной единицей скелета является кость. Кроме выполнения защитной и опорной функцияй, кости участвуют в минеральном обмене и выполняют кроветворную функцию. Кости образованы в основном соединительной костной тканью. Клетки этой ткани называются остеоциты. Они окружены мельчайшими «канальцами», заполненными межклеточной жидкостью. Через межклеточную жидкость канальцев происходит питание и дыхание костных клеток. Межклеточное вещество имеет высокую плотность и составляет около 2/3 всего объема соединительной костной ткани. В костных каналах проходят нервы и кровеносные сосуды. В её состав входят органические вещества (придающие костям гибкость и упругость), и неорганические вещества, главным образом минеральные соли фосфора, кальция, магния (придающие костям твёрдость). Прочность кости обеспечивается сочетанием твердости её неорганических соединений с упругостью органических. Среднюю часть кости называют диафизом, а концевые суставные головки—эпифизами. Внутри диафиза находится канал, наполненный жёлтым костным мозгом. Эпифизы бедренной кости образованы губчатым веществом, промежутки между которым заполнены красным костным мозгом. Эпифизы кости покрыты хрящом. За счет деления клеток хряща кость растет в длину. Поверхность кости покрыта снаружи особой оболочкой из соединительной ткани-надкостницей, обеспечивающей рост кости в толщину, чувствительность, питание, срастание костей после переломов. В надкостнице проходит большое количество кровеносных сосудов и расположено множество нервных окончаний. На суставных поверхностях надкостницы нет. <-- Виды костей и их соединения --> Трубчатые—длинные (плечевая, бедренная) содержат жёлтый костный мозг. Короткие губчатые—(кости запястья, предплюсны). Плоские—(лопатки, ребра, тазовые кости) содержат красный костный мозг, выполняющий кроветворную функцию. Смешанные—состоят из нескольких частей, имеющих различное строение и происхождение (позвонки, некоторые кости черепа). Соединения нужны либо для того, чтобы одни кости могли двигаться относительно других, либо для того, чтобы соединить несколько костей в одно прочное образование. Неподвижное (непрерывное) соединение — кости срастаются или скреплены соединительной тканью (соединения костей крыши черепа). Полуподвижное — кости соединены между собой через упругие хрящевые прокладки (это соединения позвонков межпозвоночными хрящевыми дисками в шейном, грудном и поясничном отделах; соединение ребер с грудиной и грудными позвонками Подвижное (прерывное) соединения — это суставы. Сустав образован суставными поверхностями по форме строго соответствующих друг другу, покрытыми суставным хрящом, который способствует скольжению и защищает кость от стирания. Место контакта костей прикрыто прочной оболочкой из соединительной ткани – суставной сумкой, образующей герметичную суставную полость, содержащую суставную жидкость. <-- Отделы скелета --> Осевой скелет: скелет головы (череп), скелет туловища; Добавочный скелет: скелет верхних конечностей (пояс верхних конечностей + свободная конечность), скелет нижних конечностей (пояс нижних конечностей + свободная конечность). Скелет головы (череп). Череп образован прочной мозговой коробкой и разделен на лицевой и мозговой отделы. Мозговой отдел черепа образован прочно и неподвижно соединенными между собой костями. Это парные теменные и височные кости и непарные лобная и затылочная кости. Лицевой отдел черепа состоит из 15 костей. Самые крупные кости лицевого черепа — верхняя и нижняя челюсти, в их ячейках расположены корни зубов. В черепе есть только одна подвижная кость – нижняя челюсть. Все остальные кости черепа соединены неподвижно. Скелет туловища включает позвоночник, состоящий из 5 отделов: Шейный отдел — 7 позвонков. Грудной отдел — 12 позвонков. К первым 7 прикрепляются ребра, срастающиеся с грудиной. Остальные позвонки несут ложные ребра. Грудные позвонки, ребра и грудина образуют грудную клетку. Поясничный отдел — 5 позвонков. Крестцовый отдел — 5 позвонков, срастающихся к 18—20 годам и образующих крестец. Копчиковый отдел — 4—5 позвонков. Позвоночник человека образует изгибы (S-образный): два изгиба (шейный и поясничный) направлены выпуклостью вперед (лордоз), два изгиба (грудной и крестцовый) направлены выпуклостью назад (кифоз). Пояс верхних конечностей (плечевой пояс): парные лопатки, парные ключицы. Скелет свободной верхней конечности (плечо, предплечье, кисть) образован плечевой костью, костями предплечья – локтевой и лучевой, и костями кисти. Пояс нижних конечностей (тазовый пояс) состоит из 2 тазовых костей, каждая из которых образована сросшимися подвздошной, лобковой и седалищной костями. Таз соединяет свободные конечности с туловищем и образует полость, содержащие некоторые внутренние органы. Скелет свободной нижней конечности (бедро, голень, стопа) состоит из бедренной, большой и малой берцовых костей, костей стопы. Стопа состоит из семи костей предплюсны (самая крупная - пяточная), пяти костей плюсны и фаланг пальцев (в большом пальце две и по три в остальных). У человека стопа сводчатая, чтобы смягчать толчки, возникающие при ходьбе, беге и прыжках, что является ещё одним приспособлением к прямохождению."};

int startPos = 0;                                 // Позиция, с которой выводим текст
int endPos = 0;

int positions[500];
int currentPos = 0;

void setup() {
  button.setClickTimeout(300);                    // Устанавливаем таймаут кнопки

  oled.init();                                    // Инициализация дисплей
  oled.clear();                                   // Очистить дисплей
  oled.autoPrintln(true);                         // Автоматически переносить текст

  oled.home();                                    // Курсор в 0,0
  oled.setScale(2);                               // Масштаб 2
  oled.print("AcruxTech OLED v1.0");              // Выводим логотип
  initText();
  delay(2000);                                    // Ждём 2 сек

  oled.clear();                                   // Очищаем дисплей
  oled.home();                                    // Идём в 0,0
  oled.setScale(1);                               // мастшаб 1
}
void loop() {
  static bool flag = true;
  button.tick();                                  // Опрос кнопки
  if (button.isSingle()) {                        // Если кнопка нажата 1 раз
    oled.clear();                                 // Очищаем дислей
    oled.home();                                  // Идём в 0,0
    if (flag) {                                   // Если флаг начального текста поднят
      oled.print(drawText(positions[currentPos]));  // Рисуем текст с текущей позиции, т.е. с нулевой
      flag = false;                               // Опускаем флаг
    }
    else {                                        // В противном случае
      if (currentPos < endPos - 1) currentPos++;  // Если еще можно листать вперёд, листаем вперёд
      oled.print(drawText(positions[currentPos]));  // Выводим текст
    }
  }
  if (button.isDouble()) {                        // Если кнопка нажата 2 раза
    oled.clear();                                 // Очищаем дислей
    oled.home();                                  // Идём в 0,0
    if (currentPos > 0) currentPos--;             // Если еще можно листать назад, листаем назад
    oled.print(drawText(positions[currentPos]));  // Выводим текст
  }
}

String drawText(int _startPos) {                  // Функция рисования текста
  byte _amountSymbolsDouble = 0;                  // Количество выведенных символов
  String _outputString = "";                      // Конечная строка

  for (int i = _startPos; i < strlen_P(text); i++) {  // Побайтово считываем с начальной позиции до конца текста
    if (_amountSymbolsDouble > 168) break;        // Если количество символов больше 168, прерываем цикл
    if (pgm_read_byte(&text[i]) > 127) {          // Если символ русский (см. кодировку UTF-8)
      _outputString += (char)pgm_read_byte(&text[i]); // К строке прибавляем этот символ
      _amountSymbolsDouble++;                     // Увеличиваем счётчик
      continue;                                   // Пропускаем следующую иттерацию (см. кодировку UTF-8)
    }
    else {                                        // Если символ русский
      _outputString += (char)pgm_read_byte(&text[i]); // К строке прибавляем этот символ
      _amountSymbolsDouble += 2;                  // Увеличиваем счётчик на 2 (см. кодировку UTF-8)
    }
  }
  return _outputString;                           // В конце отдаём получившуюся строку
}

void initText() {                                 // Функция расчёта позиций текста
  byte _amountSymbolsDouble = 0;                  // Количество выведенных символов
  bool _flag = true;                              // Флаг конца текста

  positions[0] = 0;                               // В нулевую позицию ОБЯЗАТЕЛЬНО пишем 0, чтобы не пропускать начало текста

  for (int pos = 1; pos < 500; pos++) {           // Начинаем цикл с 1 и до конца
    _amountSymbolsDouble = 0;                     // Каждый раз обнуляем кол-во символов
    if (!_flag) {                                 // Если текст кончился
      endPos = pos - 1;                           // Последний экран приравниваем к последней позиции минус 1
      break;                                      // Выходим из цикла
    }
    for (int i = startPos; i < strlen_P(text); i++) { // Для каждой следующей позиции определяем начальную
      if (i == strlen_P(text) - 1) _flag = false; // Если текст кончился, ставим флаг
      if (_amountSymbolsDouble > 168) {           // Если максимальное кол-во символов достигнуто
        startPos += i - startPos - 1;             // Считаем начальную позицию
        positions[pos] = startPos;                // И пишем её в массив
        break;                                    // Выходим из цикла
      }
      if (pgm_read_byte(&text[i]) > 127) {        // Если символ русский, увеличиваем счётчик на 1 и пропускаем иттерацию
        _amountSymbolsDouble++;
        continue;
      }
      else {                                      // Если символ не русский, увеличиваем счётчик на 2 (см. кодировку UTF-8)
        _amountSymbolsDouble += 2;
      }
    }
  }
}
